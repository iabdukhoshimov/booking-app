// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: vote.sql

package sqlc

import (
	"context"
)

const createVote = `-- name: CreateVote :exec
INSERT INTO vote (phone_number, initiative_id, board_id)
VALUES (
        $1,
        $2,
        $3
    )
`

type CreateVoteParams struct {
	PhoneNumber  string `json:"phone_number"`
	InitiativeID string `json:"initiative_id"`
	BoardID      string `json:"board_id"`
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) error {
	_, err := q.db.Exec(ctx, createVote, arg.PhoneNumber, arg.InitiativeID, arg.BoardID)
	return err
}

const deleteVote = `-- name: DeleteVote :exec
DELETE FROM vote
WHERE phone_number = $1
    AND board_id = $2
`

type DeleteVoteParams struct {
	PhoneNumber string `json:"phone_number"`
	BoardID     string `json:"board_id"`
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) error {
	_, err := q.db.Exec(ctx, deleteVote, arg.PhoneNumber, arg.BoardID)
	return err
}

const getAllVotes = `-- name: GetAllVotes :many
SELECT phone_number, initiative_id, board_id, created_at, updated_at
FROM vote
WHERE board_id = $1
ORDER BY created_at DESC OFFSET $2
LIMIT $3
`

type GetAllVotesParams struct {
	BoardID string `json:"board_id"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) GetAllVotes(ctx context.Context, arg GetAllVotesParams) ([]Vote, error) {
	rows, err := q.db.Query(ctx, getAllVotes, arg.BoardID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vote
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.PhoneNumber,
			&i.InitiativeID,
			&i.BoardID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
