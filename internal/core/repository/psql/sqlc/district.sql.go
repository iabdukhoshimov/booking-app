// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: district.sql

package sqlc

import (
	"context"

	null "gopkg.in/guregu/null.v4"
)

const createDistrict = `-- name: CreateDistrict :one
INSERT INTO district(title, region_id)
VALUES ($1, $2) RETURNING id
`

type CreateDistrictParams struct {
	Title    string `json:"title"`
	RegionID int32  `json:"region_id"`
}

func (q *Queries) CreateDistrict(ctx context.Context, arg CreateDistrictParams) (int32, error) {
	row := q.db.QueryRow(ctx, createDistrict, arg.Title, arg.RegionID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteDistrictByID = `-- name: DeleteDistrictByID :exec
DELETE FROM district
WHERE id = $1
`

func (q *Queries) DeleteDistrictByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDistrictByID, id)
	return err
}

const getAllDistricts = `-- name: GetAllDistricts :many
SELECT id, title, region_id
FROM district
WHERE district.title ilike '%' || $1::VARCHAR || '%'
    AND CASE
        WHEN $2::INTEGER = 0 THEN TRUE
        ELSE district.region_id = $2::INTEGER
    END
LIMIT $4 OFFSET $3
`

type GetAllDistrictsParams struct {
	Search   string `json:"search"`
	RegionID int32  `json:"region_id"`
	Offset   int32  `json:"offset_"`
	Limit    int32  `json:"limit_"`
}

func (q *Queries) GetAllDistricts(ctx context.Context, arg GetAllDistrictsParams) ([]District, error) {
	rows, err := q.db.Query(ctx, getAllDistricts,
		arg.Search,
		arg.RegionID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []District
	for rows.Next() {
		var i District
		if err := rows.Scan(&i.ID, &i.Title, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDistrictsCount = `-- name: GetAllDistrictsCount :one
SELECT COUNT(1)
FROM district
WHERE district.title ilike '%' || $1::VARCHAR || '%'
    AND CASE
        WHEN $2::INTEGER = 0 THEN TRUE
        ELSE district.region_id = $2::INTEGER
    END
`

type GetAllDistrictsCountParams struct {
	Search   string `json:"search"`
	RegionID int32  `json:"region_id"`
}

func (q *Queries) GetAllDistrictsCount(ctx context.Context, arg GetAllDistrictsCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getAllDistrictsCount, arg.Search, arg.RegionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDistrictByID = `-- name: GetDistrictByID :one
SELECT id, title, region_id
FROM district
WHERE id = $1
`

func (q *Queries) GetDistrictByID(ctx context.Context, id int32) (District, error) {
	row := q.db.QueryRow(ctx, getDistrictByID, id)
	var i District
	err := row.Scan(&i.ID, &i.Title, &i.RegionID)
	return i, err
}

const getDistrictByRegionID = `-- name: GetDistrictByRegionID :many
SELECT id, title, region_id
FROM district
WHERE region_id = $1
`

func (q *Queries) GetDistrictByRegionID(ctx context.Context, regionID int32) ([]District, error) {
	rows, err := q.db.Query(ctx, getDistrictByRegionID, regionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []District
	for rows.Next() {
		var i District
		if err := rows.Scan(&i.ID, &i.Title, &i.RegionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDistrict = `-- name: UpdateDistrict :exec
UPDATE district
SET title = COALESCE($1, title),
    region_id = COALESCE($2, region_id)
WHERE id = $3
`

type UpdateDistrictParams struct {
	Title    null.String `json:"title"`
	RegionID null.Int    `json:"region_id"`
	ID       int32       `json:"id"`
}

func (q *Queries) UpdateDistrict(ctx context.Context, arg UpdateDistrictParams) error {
	_, err := q.db.Exec(ctx, updateDistrict, arg.Title, arg.RegionID, arg.ID)
	return err
}
